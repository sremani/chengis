(ns chengis.engine.vulnerability-scanner
  "Container and artifact vulnerability scanning engine.
   Runs scanners (trivy or grype) against build targets, parses results,
   evaluates thresholds, and persists scan records.
   Gated by the :container-scanning feature flag."
  (:require [chengis.db.scan-store :as scan-store]
            [chengis.engine.process :as process]
            [chengis.feature-flags :as feature-flags]
            [clojure.data.json :as json]
            [clojure.string :as str]
            [taoensso.timbre :as log]))

;; ---------------------------------------------------------------------------
;; Severity ordering for threshold evaluation
;; ---------------------------------------------------------------------------

(def ^:private severity-order
  {"critical" 0 "high" 1 "medium" 2 "low" 3})

;; ---------------------------------------------------------------------------
;; Trivy parser
;; ---------------------------------------------------------------------------

(defn parse-trivy-results
  "Parse Trivy JSON output.
   Trivy format: {\"Results\": [{\"Vulnerabilities\": [{\"Severity\": \"CRITICAL\"}, ...]}]}.
   Count by severity. Returns {:critical n :high n :medium n :low n :total n}.
   Returns zeroed counts on parse error."
  [stdout]
  (try
    (let [parsed (json/read-str stdout :key-fn keyword)
          results (:Results parsed)
          vulns (mapcat (fn [r] (or (:Vulnerabilities r) [])) results)
          by-severity (frequencies (map (fn [v]
                                          (str/lower-case (or (:Severity v) "unknown")))
                                        vulns))
          critical (get by-severity "critical" 0)
          high (get by-severity "high" 0)
          medium (get by-severity "medium" 0)
          low (get by-severity "low" 0)]
      {:critical critical
       :high high
       :medium medium
       :low low
       :total (+ critical high medium low)})
    (catch Exception e
      (log/warn "Failed to parse Trivy results" {:error (.getMessage e)})
      {:critical 0 :high 0 :medium 0 :low 0 :total 0})))

;; ---------------------------------------------------------------------------
;; Grype parser
;; ---------------------------------------------------------------------------

(defn parse-grype-results
  "Parse Grype JSON output.
   Grype format: {\"matches\": [{\"vulnerability\": {\"severity\": \"Critical\"}, ...}]}.
   Count by severity (case-insensitive). Returns same shape as trivy."
  [stdout]
  (try
    (let [parsed (json/read-str stdout :key-fn keyword)
          matches (or (:matches parsed) [])
          by-severity (frequencies (map (fn [m]
                                          (str/lower-case
                                            (or (get-in m [:vulnerability :severity]) "unknown")))
                                        matches))
          critical (get by-severity "critical" 0)
          high (get by-severity "high" 0)
          medium (get by-severity "medium" 0)
          low (get by-severity "low" 0)]
      {:critical critical
       :high high
       :medium medium
       :low low
       :total (+ critical high medium low)})
    (catch Exception e
      (log/warn "Failed to parse Grype results" {:error (.getMessage e)})
      {:critical 0 :high 0 :medium 0 :low 0 :total 0})))

;; ---------------------------------------------------------------------------
;; Threshold evaluation
;; ---------------------------------------------------------------------------

(defn evaluate-threshold
  "Given counts map and threshold string, return true (passed) if no vulns
   at that severity or above.
   E.g., threshold \"high\" passes if critical-count=0 AND high-count=0."
  [counts threshold]
  (let [threshold-level (get severity-order (str/lower-case (or threshold "critical")) 0)]
    (every? (fn [[sev level]]
              (if (<= level threshold-level)
                (zero? (get counts (keyword sev) 0))
                true))
            severity-order)))

;; ---------------------------------------------------------------------------
;; Target detection
;; ---------------------------------------------------------------------------

(defn detect-scan-targets
  "Detect docker images from build pipeline-source and artifacts.
   Returns list of target strings."
  [build-result config]
  (let [pipeline-source (:pipeline-source build-result)
        ;; Look for docker image patterns in pipeline source
        docker-images (when (string? pipeline-source)
                        (re-seq #"(?:docker\.io/|ghcr\.io/|registry\.[^/]+/)?[\w.-]+/[\w.-]+:[\w.-]+" pipeline-source))
        ;; Check artifacts for image references
        artifact-images (when-let [artifacts (:artifacts build-result)]
                          (keep (fn [a]
                                  (when (and (:filename a)
                                             (or (str/ends-with? (:filename a) ".tar")
                                                 (str/ends-with? (:filename a) ".tar.gz")))
                                    (:path a)))
                                artifacts))
        ;; Configured targets
        configured (get config :targets [])
        all-targets (concat (or docker-images [])
                            (or artifact-images [])
                            configured)]
    (vec (distinct all-targets))))

;; ---------------------------------------------------------------------------
;; Main entry point
;; ---------------------------------------------------------------------------

(defn scan-build!
  "Run vulnerability scanning for a completed build.
   Gated by the :container-scanning feature flag.
   For each target, runs the configured scanner (trivy or grype) via process/execute-command.
   Parses results, evaluates threshold, stores in DB.
   Graceful degradation if tool not found.
   Config from (get-in system [:config :container-scanning])."
  [system build-result]
  (when (feature-flags/enabled? (:config system) :container-scanning)
    (try
      (let [ds (:db system)
            config (get-in system [:config :container-scanning])
            scanner (or (:scanner config) "trivy")
            threshold (or (:threshold config) "critical")
            timeout (or (:timeout config) 300000)
            build-id (:build-id build-result)
            job-id (:job-id build-result)
            org-id (or (:org-id build-result) "default-org")
            targets (detect-scan-targets build-result config)
            parse-fn (case scanner
                       "trivy" parse-trivy-results
                       "grype" parse-grype-results
                       parse-trivy-results)]
        (when (seq targets)
          (let [results (doall
                          (for [target targets]
                            (try
                              (let [command (case scanner
                                             "trivy" (str "trivy image --format json " target)
                                             "grype" (str "grype " target " -o json")
                                             (str scanner " " target))
                                    result (process/execute-command
                                             {:command command
                                              :dir (:workspace build-result)
                                              :timeout timeout})]
                                (cond
                                  ;; Timed out â€” check first, a timed-out scan should fail
                                  (:timed-out? result)
                                  (do (log/warn "Scanner timed out" {:scanner scanner :target target})
                                      (scan-store/create-scan! ds
                                        {:build-id build-id
                                         :job-id job-id
                                         :org-id org-id
                                         :scan-target target
                                         :scanner scanner
                                         :scanner-version nil
                                         :critical-count 0 :high-count 0 :medium-count 0 :low-count 0 :total-count 0
                                         :pass-threshold threshold
                                         :passed 0
                                         :results-json nil}))

                                  ;; Tool not found
                                  (= 127 (:exit-code result))
                                  (do (log/warn "Scanner tool not found" {:scanner scanner})
                                      nil)

                                  ;; Scanner may return non-zero for vuln findings
                                  ;; Parse output regardless if stdout is non-empty
                                  :else
                                  (let [stdout (:stdout result)
                                        counts (if (seq stdout)
                                                 (parse-fn stdout)
                                                 {:critical 0 :high 0 :medium 0 :low 0 :total 0})
                                        passed (evaluate-threshold counts threshold)]
                                    (scan-store/create-scan! ds
                                      {:build-id build-id
                                       :job-id job-id
                                       :org-id org-id
                                       :scan-target target
                                       :scanner scanner
                                       :scanner-version nil
                                       :critical-count (:critical counts)
                                       :high-count (:high counts)
                                       :medium-count (:medium counts)
                                       :low-count (:low counts)
                                       :total-count (:total counts)
                                       :pass-threshold threshold
                                       :passed (if passed 1 0)
                                       :results-json stdout}))))
                              (catch Exception e
                                (log/warn "Vulnerability scan exception" {:target target :error (.getMessage e)})
                                nil))))]
            (let [successful (filterv some? results)]
              (log/info "Vulnerability scanning complete" {:build-id build-id
                                                          :targets (count targets)
                                                          :successful (count successful)})
              (when (seq successful)
                successful)))))
      (catch Exception e
        (log/warn "Vulnerability scanning failed" {:error (.getMessage e)})
        nil))))
